---
title: "Two-Component Implementation in LaplacesDemon"
output: 
  html_notebook:
    toc: true
bibliography: disease_sim_proj.bib
link-citations: yes
---

# Introduction: Two-Component Attempt in LaplacesDemon

@held_two-component_2006

Attempt to recreate bayesian portion: the data is now in ```counts```

## Data Simulated
```{r change point model}
library(LaplacesDemon)

n = 199 #total epochs/time steps
ende_lambda = rep(20, n) #vector of endemic lambda values (\nu)
epi_lambda = rep(0.5, n)  #vector of epidemic lambda values
init = 30   #Z_0 value is the initial number of people infected


ende_lambda = rep(0.5, n) #vector of endemic lambda values (\nu)

#---simulate endemic component based on paper's values----#



rho = 2*pi/52
gamma_0 = log(10)
gamma_1 = 0.5
gamma_2 = 1.5


nu_t = gamma_0 + gamma_1*sin(rho*(1:n)*(1+1)/2) + gamma_2*cos(rho*(1:n)*(2+1)/2)

ende_lambda = exp(nu_t)
plot(ende_lambda)

#-----setting epidemic lambda values 
epi_lambda = rep(c(0.7, 1.2, 0.7), c(39,10,155))

ende_lambda1 <- ende_lambda

counts = rep(0, n) #initialize count vector
counts[1] = init #initial value

ende = rep(0, n)
epi = rep(0, n)

for (i in 1:n) {
  ende[i] = rpois(1, ende_lambda[i])
  epi[i] = rpois(1, epi_lambda[i]*counts[i])
  
  counts[i+1] = ende[i] + epi[i]
}

plot(counts, type = "l")
lines(ende, type = "l", col = "red")
lines(epi, type = "l", col = "blue")
```


# LaplacesDemon Model Creation

## Data
```{r data}
n_cp = 2

parm_names = as.parm.names(list(epi_lambda = rep(0,n_cp+1),
                                gamma = rep(0,3),
                                cp = rep(0, n_cp))
                           )

pos_epi_lambda <- grep("epi_lambda", parm_names)
pos_gamma <- grep("gamma", parm_names)
pos_cp <- grep("cp", parm_names)

data_list_1 = list(N = length(counts),
                 counts = counts,
                 mon.names = c("post_lik"),
                 parm.names = parm_names)
```

## Model
```{r}
model_1 <- function(parm, data) {
  # number is actually 200 with 1 initial value
  N <- data$N
  counts = data$counts

  #make lambdas positive, and let the model know
   epi_lambda <- parm[pos_epi_lambda]
  # if (any(epi_lambda<0)){
  #        return(list(LP = -500000,
  #      Dev = -2 * -500000,
  #      Monitor = c(-500000),
  #      yhat = NA,
  #      parm = parm))
  #   
  # }
   epi_lambda <- abs(epi_lambda)
  parm[pos_epi_lambda] <- epi_lambda #let the model know
  
  
  #------from gammas generate the epidemic parameter
  gammas <- parm[pos_gamma] 
  
  rho = 2*pi/52
  gamma_0 = gammas[1]
  gamma_1 = gammas[2]
  gamma_2 = gammas[3]
  

  nu_t = gamma_0 + gamma_1*sin(rho*(1:N)*(1+1)/2) + gamma_2*cos(rho*(1:N)*(2+1)/2)
  

  ende_lambda = exp(nu_t[1:N-1])
  
  #print(which(ende_lambda1 == ende_lambda))
  

  
  
  #----change point and force it to be in an interval ------
  
  cp <- interval(parm[pos_cp], 0, N)  #N change points
  cp <- sort(ceiling(cp))
  parm[pos_cp] <- cp 
  
  # if (cp[1] > cp[2]) {
  #    return(list(LP = -500000,
  #      Dev = -2 * -500000,
  #      Monitor = c(-500000),
  #      yhat = NA,
  #      parm = parm))
  # }
    #constrained so replace
  
  #The cp parameter must be integer-only, and so it is constrained function.
  #The algorithm, outside of the Model function needs to be aware that cp has been
  #constrained, so the parm vector is updated with the constrained values
  
  
  lambdas <- rep(epi_lambda, diff(c(0, cp, N)))

  
  #--------------------likelihoods-----------
  log_lik <- sum(dpois(data$counts[2:N],
                       counts[1:(N-1)]*lambdas[1:(N-1)]+ ende_lambda,
                       log = TRUE))
  
  post_lik <- log_lik +
    sum(dgamma(epi_lambda, 10,10, log = TRUE)) +  #prior on epidemics
    sum(dunif(cp, 0, 200, log=T)) #prior on change points
    + sum(dnorm(gammas, 0, 6), log = TRUE) #prior on gamma values
  
  # This list is returned and has to follow a the format specified by
  # LaplacesDemon.  
  list(LP = post_lik,
       Dev = -2 * log_lik,
       Monitor = c(post_lik),
       yhat = NA,
       parm = parm)
}



```

## flat likelihood issues

```{r}
inits <- c(rexp(n_cp+1, 2),log(10),0.5,1.5,  runif(n_cp, 1, 198))
inits <- c(0.5, 1.2, 0.5, 39, 49)

inits <- c(1.0775867,0.5132553, 0.6676782,1,200)


#true
model_1(c(0.1, 5, 0.1,log(10),0.5,1.5, 39, 49), data_list_1)$LP

#converges values
#model_1(c(1.0775867,0.5132553, 0.6676782,60,200), data_list_1)$LP


postmat = matrix(0, nrow = 100, ncol = 100)

for (i in 1:100) {
  for (j in 1:100) {
    postmat[i,j] <- model_1(c(0.5, 1.2, 0.5,log(10),0.5,1.5, i, j), data_list_1)$LP
  }
}

true_vals <- plot_ly(z = postmat) %>% add_surface()
wrongvals <- p


```

## Initial samples

```{r}
initcp <- runif(1,0,200)
initlambda <- rbeta(1,2,2)
gam1 = 2
gam2 = 2
gam3 = 2
inits <- c(initlambda,initlambda*3,initlambda,4,2,2,  runif(1,0,200),runif(1,0,200))
inits <- c(1,0.1,0.1,6,1,1,1,200)
inits <- c(rexp(1, 1),rexp(2,0.5),log(10),0.5,1.5,  runif(n_cp, 1, 198))
print(inits)
mcmc_samples <- LaplacesDemon(Model = model_1,
                              Initial.Values = inits,
                              Data = data_list_1, 
                              Iterations = 5000,
                              Specs=list(alpha.star=0.234, B=NULL),
                              Algorithm = "CHARM", Thinning = 1)

Consort(mcmc_samples)
bayesplot::mcmc_trace(mcmc_samples$Posterior1)
```
```{r}
tough1 <- c(0.667, 2.003, 0.667, 1.328, 0.664, 0.665, 122,12)
inits <-
```

## Extended samples

```{r}
Initial.Values <- as.initial.values(mcmc_samples)
mcmc_samples <- LaplacesDemon(model_1, Data=data_list_1, Initial.Values,
     Covar=mcmc_samples$Covar, Iterations=4e+05, Status=34482, Thinning=40,
     Algorithm="AMWG", Specs=list(B=NULL, n=10000, Periodicity=148))
```


```{r}
mcmc_samples
```

## Trace Plots

```{r}
bayesplot::mcmc_trace(mcmc_samples$Posterior1)
```


#Simulate Graph Data

```{r simulate p25}
library(igraph)
N = 200 #total epochs/time steps
init = 10   #Z_0 value is the initial number of people infected
graph = sample_gnp(5, 1) #speed check

#---simulate endemic component based on paper's values----#
#-----------NOTE: need to divide the rate since each city gets a chance
rho = 2*pi/52
gamma_0 = log(10)
gamma_1 = 0.5
gamma_2 = 1.5


nu_t = gamma_0 + gamma_1*sin(rho*(1:N)*(1+1)/2) + gamma_2*cos(rho*(1:N)*(2+1)/2)


#need to divide!
ende_lambda = rep(0, N)
ende_lambda = exp(nu_t)/gorder(graph)


#-----setting epidemic lambda values 
epi_lambda = rep(c(0.7, 1.2, 0.7)/(gorder(graph)), c(39,10,150))






#----separate count figures----#
ende_c = matrix(0, nrow = gorder(graph), ncol = N-1)
epi_c = matrix(0, nrow = gorder(graph), ncol = N-1)



#----------------

#-----------------counts matrix ------



graph_counts = matrix(0, nrow = gorder(graph), ncol = N)
graph_counts[,1] = init

#counts = rep(0, n) #initialize count vector
#counts[1] = init #initial value
 

#get list of all adjacent vertices
adj = adjacent_vertices(graph, 1:gorder(graph))



#-----------

for (i in 1:(N - 1)) {
  #all rows/cities get same value
  ende_c[, i] = rpois(gorder(graph), ende_lambda[i])
  
  for (j in 1:gorder(graph)) {
    counts_j = sum(graph_counts[adj[[j]], i]) #sum all adjacent counts
    counts_j = counts_j + graph_counts[j, i] #add self count
    epi_c[j, i] = rpois(1, epi_lambda[i] * counts_j) #generate new counts
    graph_counts[j , i + 1] = ende_c[j, i] + epi_c[j, i] #append new counts
  }
  
  
}

plot(graph)



plot(colSums(graph_counts), type = 'l')
lines(colSums(ende_c), col = 'blue', type = 'l')
lines(colSums(epi_c), col = 'red', type = 'l')
title(main = "all cities sum")

plot(graph_counts[1, ], type = 'l', col = 'forestgreen')
lines(ende_c[1, ], type = 'l', col = 'blue')
lines(epi_c[1, ], type = 'l', col = 'red')
title(main = 'city 1')

plot(graph_counts[10, ], type = 'l', col = 'forestgreen')
lines(ende_c[10, ], type = 'l', col = 'blue')
lines(epi_c[10, ], type = 'l', col = 'red')
title(main = 'city 10')

rpois(1, ende_lambda[2] + epi_lambda[2]*sum(graph_counts[,2]))
```



# Graph Laplaces Demon

## data

```{r}
library(LaplacesDemon)
n_cp = 2

parm_names = as.parm.names(list(epi_lambda = rep(0,n_cp+1),
                                gamma = rep(0,3),
                                cp = rep(0, n_cp),
                                gp = 0)
                           )

pos_epi_lambda <- grep("epi_lambda", parm_names)
pos_gamma <- grep("gamma", parm_names)
pos_cp <- grep("cp", parm_names)
pos_p <- grep("gp", parm_names)


data_list = list(N = dim(graph_counts)[2],
                 order = dim(graph_counts)[1],
                 counts = graph_counts,
                 mon.names = c("post_lik"),
                 parm.names = parm_names)
```


## model



```{r LP model graph}

model <- function(parm, data) {
  # number is actually 200 with 1 initial value
  N <- data$N

  ord <- data$order

  
  counts = data$counts
  
  p = interval(parm[pos_p], 0,1)
  parm[pos_p] = p

  #make lambdas positive, and let the model know
  epi_lambda <- abs(parm[pos_epi_lambda])
  parm[pos_epi_lambda] <- epi_lambda #let the model know
  
  
  #------from gammas generate the epidemic parameter
  gammas <- parm[pos_gamma] 
  
  rho = 2*pi/52
  gamma_0 = gammas[1]
  gamma_1 = gammas[2]
  gamma_2 = gammas[3]
  

  nu_t = gamma_0 + gamma_1*sin(rho*(1:N)*(1+1)/2) + gamma_2*cos(rho*(1:N)*(2+1)/2)
  
  ende_lambda = exp(nu_t[1:(N - 1)]) #only need N-1 since first is seeded
  mat_ende_lambda <- matrix(ende_lambda, nrow = ord, ncol = (N-1), byrow = TRUE)
  

  
  
  #----change point and force it to be in an interval ------
  
  cp <- interval(parm[pos_cp], 0, N)  #N change points
  cp <- ceiling(sort(cp))
  parm[pos_cp] <- cp  #constrained so replace
  
  #The cp parameter must be integer-only, and so it is constrained function.
  #The algorithm, outside of the Model function needs to be aware that cp has been
  #constrained, so the parm vector is updated with the constrained values
  
  lambdas <- rep(epi_lambda, diff(c(0, cp, N)))
  mat_lambdas <- matrix(lambdas, nrow = ord, ncol = length(lambdas), byrow = TRUE)
  
  
  #graph
  
  graph = sample_gnp(ord, p)
  #plot(graph)
  

  
  
  adj = adjacent_vertices(graph, 1:gorder(graph))

  
  #--------------------likelihoods-----------
  
  #for each city
  
# this partitions
 ord = gorder(graph) #the number of vertices/cities/rows

#get adjacency list
adj = adjacent_vertices(graph, 1:gorder(graph))

inf_counts = matrix(0, nrow = gorder(graph), ncol = N)

#recompute counts into infection potential counts

for (i in 1:gorder(graph)) {
    adji <- adj[[i]]

    if(length(adji)>0){
    inf_counts[i, ] = colSums(counts[adji, , drop = FALSE]) + counts[i, ]
    } else {
      inf_counts[i, ] = counts[i, ]
    }
    
}



#creates matrix of repeated rows



#creates matrix of lambdas from estimated lambda row

#compute the log-likelihood
log_lik <- sum(dpois(counts[ ,2:N], #data is for 2:N, first column is an initial value
                       inf_counts[ ,1:(N - 1)]*mat_lambdas[, 1:(N - 1)] + mat_ende_lambda[, 1:(N-1)],
                       log = TRUE))
  
  post_lik <- log_lik +
    sum(dgamma(epi_lambda, 10,10, log = TRUE)) +  #prior on epidemics
    sum(dunif(cp, 0, 200, log = T)) +   #prior on change points
    sum(dnorm(gammas, 0, 5), log = TRUE) +
    dbeta(p,1,1,log=TRUE)
  
  # This list is returned and has to follow a the format specified by
  # LaplacesDemon.  
  list(LP = post_lik,
       Dev = -2 * log_lik,
       Monitor = c(post_lik),
       yhat = NA,
       parm = parm)

}

inits <- c(rexp(n_cp + 1, 2), log(20),1, 3 ,runif(n_cp,1,199), 0.3)

```

```{r}

undebug(model)
model(c(0.7/7,1/10,0.7/10,log(10),0.5,2,39,49,0.95), data_list)
inits <- c(0.1,0.9,0.1,2,0.5,1.5,1,200,1)
```

# initial samples
```{r}
mcmc_samples <- LaplacesDemon(Model = model, Initial.Values = inits, Data = data_list, 
                              Iterations = 3000, Specs=list(alpha.star=0.234, B=NULL),
                              Algorithm = "RWM", Thinning = 1, Status = 100)

Consort(mcmc_samples)
bayesplot::mcmc_trace(mcmc_samples$Posterior1)
```

```{r}
Initial.Values <- as.initial.values(mcmc_samples)
mcmc_samples <- LaplacesDemon(model, Data=data_list, Initial.Values,
     Covar=NULL, Iterations=1320000, Status=25210, Thinning=44,
     Algorithm="/'HARM", Specs=list(alpha.star=0.234, B=NULL))
```



# Citations