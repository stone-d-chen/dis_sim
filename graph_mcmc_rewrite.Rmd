---
title: "Handwritten MCMC 2"
output: html_notebook
---

```{r}
pkgs = c("compiler", "profvis", "igraph","microbenchmark")
inst = lapply(pkgs, library, character.only = TRUE)
```


```{r rcpp}
Rcpp::cppFunction("double mypoisC(NumericVector data, NumericVector lambdas) {
  int n = data.size();
  NumericVector plik(n);
  plik = -lambdas + data*log(lambdas);

  double tlik = 0;

  for(int i = 0; i < n; ++i){
    tlik += plik[i];
  }

  return tlik;
  }")



Rcpp::cppFunction("NumericVector diff_sug(NumericVector x){
   return diff(x);
}")

Rcpp::cppFunction("NumericVector stl_sort(NumericVector x) {
   NumericVector y = clone(x);
   std::sort(y.begin(), y.end());
   return y;
}")

```





```{r graph simulation}
N = 199 #total epochs/time steps
t = 1:N
init = 10   #Z_0 value is the initial number of people infected

el = matrix(
  c(1,2,1,3,1,4,1,5,1,6, 2, 7, 2, 8, 7,8, 6,9, 9, 10),
  byrow = TRUE,
  ncol = 2)

g_city = graph_from_edgelist(el, directed = FALSE)
plot(g_city)

adjlist = as_adj_list(g_city)



#---simulate endemic component based on paper's values----#
#-----------NOTE: need to divide the rate since each city gets a chance




gamma  <- c(log(10), 0.5, 1.5)
rho <- 2*pi/52 
INDEP <- as.matrix(data.frame(x0 = 1, x1 = sin(rho*t), x2 = cos(rho*t*1.5)))

nu_t <- as.matrix(INDEP) %*% gamma


#need to divide!
ende_lambda = rep(0, N)
ende_lambda = exp(nu_t)




#-----setting epidemic lambda values 

K <- 3
theta  <- c(39, 49, 193)

lambda <- c(0.7, 1.2, 0.7, 0.95)/3.5
epi_lambda = rep(lambda, diff(c(0, theta, N)))





#----separate count figures----#
ende_c = matrix(0, nrow = gorder(g_city), ncol = N)
epi_c = matrix(0, nrow = gorder(g_city), ncol = N)



#-----------------counts matrix ------


counts = matrix(0, nrow = gorder(g_city), ncol = N)
counts[1,1] = init

#counts = rep(0, n) #initialize count vector
#counts[1] = init #initial value
 

#get list of all adjacent vertices
adj = adjacent_vertices(g_city, 1:gorder(g_city))
adj = as_adj_list(g_city)



#-----------

for (i in 1:(N - 1)) {
  #all rows/cities get same value
  ende_c[, i] = rpois(1, ende_lambda[i])
  
  for (j in 1:gorder(g_city)) {
    counts_j = sum(counts[adj[[j]], i]) #sum all adjacent counts
    counts_j = counts_j + counts[j, i] #add self count
    epi_c[j, i] = rpois(1, epi_lambda[i] * counts_j) #generate new counts
    counts[j , i + 1] = ende_c[j, i] + epi_c[j, i] #append new counts
  }
  
  
}

plot(colSums(counts), type = 'l')
lines(colSums(ende_c), col = 'blue', type = 'l')
lines(colSums(epi_c), col = 'red', type = 'l')
title(main = "all cities sum")

plot(counts[1, ], type = 'l', col = 'forestgreen')
lines(ende_c[1, ], type = 'l', col = 'blue')
lines(epi_c[1, ], type = 'l', col = 'red')
title(main = 'city 1')

plot(counts[10, ], type = 'l', col = 'forestgreen')
lines(ende_c[10, ], type = 'l', col = 'blue')
lines(epi_c[10, ], type = 'l', col = 'red')
title(main = 'city 10')


```

```{r}
compute_prior <- function(input){
    K = input$K
    theta = input$theta
    lambda = input$lambda
    gamma = input$gamma
    INDEP = input$INDEP
    LL = input$LL
    graph = input$graph
    adj = input$adj
    0
    prior_star <- -log(choose(N, K)) + sum(dgamma(lambda, 1, 1, log = TRUE)) + sum(dnorm(gamma, 0, 3, log = TRUE)) + dpois(K, 2, log = TRUE)
}
```


```{r operators}

change_gamma <- function(input) {
    K = input$K
    theta = input$theta
    lambda = input$lambda
    gamma = input$gamma
    INDEP = input$INDEP
    LL = input$LL
    graph = input$graph
    adj = input$adj
  
  
  gamma_star <- gamma + rnorm(3, 0, 0.01)
  
  input_star = input
  input_star$gamma = gamma_star
  
  LL_star <- compute_like(input_star)
  
  prior_star <-  compute_prior(input_star)
  
  post_star <- LL_star + prior_star #new log posterior
  
  U = runif(1)
  
  if (log(U) < post_star - LL) {
    
    return(list(K = K, theta = theta, lambda = lambda, LL = post_star, gamma = gamma_star, INDEP = INDEP, graph = graph, adj = adj))
    
  } else {
    return(input)
  }
  
  
}



death_theta <- function(input) {
    K = input$K
    theta = input$theta
    lambda = input$lambda
    gamma = input$gamma
    INDEP = input$INDEP
    LL = input$LL
    graph = input$graph
    adj = input$adj
    
    if (K == 0) {
      return(input)
    }


    
    #m <- sample(1:length(theta), 1)
    m <- ceiling(runif(1,0,length(theta)))
    theta_star <- theta[c(-m)]                 # remove

    lambda1 <- lambda[m]     #find adjacent values to change point m
    lambda2 <- lambda[m + 1]
    
    temp_theta = c(0, theta, N)
    j = m + 1
    
    #crate new value
    lambda0 <- lambda1^((temp_theta[j] - temp_theta[j - 1])/(temp_theta[j + 1] - temp_theta[j - 1])) * lambda2^((temp_theta[j + 1] - temp_theta[j])/(temp_theta[j+1] - temp_theta[j-1]))
    
    #new lambda proposal vector
    lambda_star <- lambda
    lambda_star[m] <- lambda0
    lambda_star <- lambda_star[-c(m + 1)]

  
    #edge case handling
    
    input_star <- input
    input_star$lambda <- lambda_star
    input_star$theta <- theta_star
    input_star$K <- K - 1

    
    LL_star <- compute_like(input_star)
    
    
    if (K == 1) {
    prior_star <-  compute_prior(input_star) 
    } else {
      prior_star <-  compute_prior(input_star)
    }
    
    post_star <- LL_star + prior_star #new log posterior
    
    proposal <- log(K) - log(N - (K - 1))

    log_jacobian <- -2*log(lambda1 + lambda2) + log(lambda0)


    alpha <- post_star  - LL + log_jacobian
   
    
    if (alpha > log(runif(1))) {
      list(K = K - 1, theta = theta_star, lambda = lambda_star, INDEP = INDEP, gamma = gamma, LL = post_star, graph = graph, adj = adj)
    }  else {
     input
      
    }
    
} 






birth_theta <- function(input) {
    K = input$K
    theta = input$theta
    lambda = input$lambda
    gamma = input$gamma
    INDEP = input$INDEP
    LL = input$LL
    graph = input$graph
    adj = input$adj
    
    if (K == N) {
      return(input)
    }
  

  
    #theta_m <- sample(setdiff(1:N, theta), 1)  # birth
    theta_m <- ceiling(runif(1, 0, N))
    while (theta_m %in% theta) {
      theta_m <- ceiling(runif(1, 0, N))
    }
    
    theta_star <- stl_sort(c(theta, theta_m))
    
    m <- which(theta_star == theta_m)      
    
    temp_theta_star = c(0, theta_star, N)
    
    u <- runif(1)
    
    
      j = m + 1
      lambda0 <- lambda[m]
      lambda1 <- lambda0*(u/(1 - u))^((temp_theta_star[j] - temp_theta_star[j - 1])/(temp_theta_star[j + 1] - temp_theta_star[j - 1]))
      lambda2 <- lambda0*((1 - u)/u)^((temp_theta_star[j + 1] - temp_theta_star[j])/(temp_theta_star[j + 1] - temp_theta_star[j - 1]))
      
      if (K == 0){
        lambda0 <- lambda[1]
      lambda1 <- lambda0*(u/(1 - u))^((temp_theta_star[j] - temp_theta_star[j - 1])/(temp_theta_star[j + 1] - temp_theta_star[j - 1]))
      lambda2 <- lambda0*((1 - u)/u)^((temp_theta_star[j + 1] - temp_theta_star[j])/(temp_theta_star[j + 1] - temp_theta_star[j - 1]))
      }
      
    
    

    
    if (m == 1) {
    
      lambda_star <- c(lambda1, lambda2, lambda[-1])
    }
    else if (m == length(theta_star)) {
      lambda_star <- c(lambda[1:K], lambda1, lambda2)
    }
    else {
      lambda_star <- c(lambda[1:(m - 1)], lambda1, lambda2, lambda[(m + 1):(K + 1)])
    }
      
    input_star <- input
    input_star$lambda <- lambda_star
    input_star$theta <- theta_star
    input_star$K <- K + 1

    
    LL_star <- compute_like(input_star)
   
    
    
    if (K == 1) {
    prior_star <-  compute_prior(input_star)
    } else {
      prior_star <-  compute_prior(input_star)
    }
    
    post_star <- LL_star + prior_star #new log posterior
    
    
    
    proposal <- -log(K + 1) + log(N - K)
    log_jacobian <- 2*log(lambda1 + lambda2) - log(lambda0)
    

    alpha <- post_star  - LL + log_jacobian
    
    if (alpha > log(runif(1))) list(K = K + 1, theta = theta_star, lambda = lambda_star, INDEP = INDEP, gamma = gamma, LL = post_star, graph = graph, adj = adj)
    else {
      input
      }

  
}
  

change_theta <- function(input) {
    K = input$K
    theta = input$theta
    lambda = input$lambda
    gamma = input$gamma
    INDEP = input$INDEP
    LL = input$LL
    graph = input$graph
    adj = input$adj
    
    
    if (K == 0 || K == N) {
      return(input)
    }
    
  
  

  K <- K
  j <- sample(1:K, size = 1) + 1# select a theta 50, 70
  #j <- ceiling(runif(1,1,K+1))
  
  
  temp_theta <- c(0, theta, N + 1)
  if(temp_theta[j+1] - temp_theta[j-1] < 2) {
    return(input)
  }
  s_star <- ceiling(runif(1,temp_theta[j - 1], temp_theta[j + 1] - 1 ))
  #s_star <- temp_theta[j] + sample(c(-1,1),1)
  
  theta_star <- theta
  theta_star[j - 1] <- s_star
  
  input_star <- input
  input_star$theta <- theta_star

   LL_star <- compute_like(input_star) #likelihood of the new parameters
   prior_star <-  compute_prior(input_star)
   post_star <- LL_star + prior_star #new log posterior

  
  #post_star <- compute_post(lambda, theta_star, nu)
  
  
  U <- runif(1)
    
    if (log(U) < post_star - LL) {
    
    return(list(K = K, theta = theta_star, lambda = lambda, INDEP = INDEP, gamma = gamma, LL = post_star, graph = graph, adj = adj))
    
  } else {
    return(input)
  }
  
}


change_lambda <- function(input) {
    K = input$K
    theta = input$theta
    lambda = input$lambda
    gamma = input$gamma
    INDEP = input$INDEP
    LL = input$LL
    graph = input$graph
    adj = input$adj
  
  
  K <- K
  j <- sample(1:(K + 1), size = 1)# select a theta 50, 70
  
  lambda_star <- lambda
  lambda_star <- lambda_star + rnorm(K + 1, 0, 0.0025)
  #lambda_star[j] <- lambda_star[j] + rnorm(1,0,0.01)
  
  input_star <- input
  input_star$lambda <- lambda_star
  
  
  LL_star <- compute_like(input_star)
  
  prior_star <-   compute_prior(input_star) 
  post_star <- LL_star + prior_star #new log posterior
  
  
  
  U = runif(1)
  if (post_star == -Inf && LL == -Inf) {return(input)}
  if (log(U) < post_star - LL) {
    
    return(list(K = K, theta = theta, lambda = lambda_star, LL = post_star, gamma = gamma, INDEP = INDEP, graph = graph, adj = adj))
    
  } else {
    return(input)
  }
  
}




## call update_theta then update number of change points K
## and lambda
## then use LL to accept or reject

 

update_param <- function(input) {


   cutoff <- 1/5
  
   p = runif(1)
   if (p < cutoff ) {
     output <- birth_theta(input)
   } else if (p < 2*cutoff ) {
     output <- change_theta(input)
   } else if (p < 3*cutoff) {
     output <- change_lambda(input)
   }  else if (p < 4*cutoff) {
     output <- change_gamma(input)
   }
      else if (p >= 4*cutoff ) {
     output <- death_theta(input)
   }


 
  return(output)

}
# 
# update_param2 <- function(input) {
# 
# 
#    cutoff <- 1/5
#   
#    p = runif(1)
# 
#     if( p < 1/2) {
#      output <- birth_theta(input)
#    } else {
#      output <- death_theta(input)
#    }
# 
# 
#   return(output)
# 
# }




```


```{r graph likelihood}


compute_like <- function(input) {
    K = input$K
    theta = input$theta
    lambda = input$lambda
    gamma = input$gamma
    INDEP = input$INDEP
    LL = input$LL
    graph = input$graph
    adj = input$adj
    
  
    if (K == 0) {
    vepi_star <- rep(lambda, N)
    
    } else {
      vepi_star <- rep(lambda, diff_sug(c(0, theta, N)))
    }

  ord = length(adj)
  inf_counts = matrix(0, nrow = ord, ncol = N)
  
  nu <- exp(INDEP %*% gamma)
  
  for (i in 1:ord) {
      #inf_counts[i, ] = colSums(counts[adj[[i]], , drop = FALSE]) + counts[i, ]
      inf_counts[i, ] = .colSums(counts[adj[[i]], , drop = FALSE], length(adj[[i]]), N) + counts[i, ]
  }
  
  #creates matrix of repeated rows
  mat_ende_lambda <- matrix(rep(nu, ord), nrow = ord, byrow = TRUE)
  
  #creates matrix of lambdas from estimated lambda row
  mat_lambdas <- matrix(rep(vepi_star, ord), nrow = ord, byrow = TRUE)
  
  #compute the log-likelihood
  log_lik <- mypoisC(counts[ ,2:N], #data is for 2:N, first column is an initial value
                         inf_counts[ , 1:(N - 1)]*mat_lambdas[, 1:(N - 1)] + mat_ende_lambda[, 1:(N - 1)])
  log_lik
}


# compute_like <- function(input){
#   0
# }

```








```{r}
ops = c(death_theta, birth_theta, change_theta, change_lambda, change_gamma)
lapply(ops, undebug)


# update number of change points theta
# 
# 
# compute_like <- cmpfun(compute_like)
# change_theta <- cmpfun(change_theta)
# birth_theta <- cmpfun(birth_theta)
# death_theta <- cmpfun(death_theta)
# change_gamma <- cmpfun(change_gamma)
# update_param <- cmpfun(update_param)

nSim <- 100000
#pre-allocate
res <- list(K = numeric(nSim),
            theta = matrix(0, nSim, N),
            lambda = matrix(0, nSim, N + 1),
            gamma = matrix(0, nSim, 3),
            graph = vector(mode = "list", N),
            p = numeric(nSim))

 





output <- list(K = 4, theta = c(49, 59, 89, 90), lambda = c(0.5, 0.7, 0.3, 0.1, 0.5), LL = -Inf,
               gamma = c(2,1,1), INDEP = INDEP, graph = g_city, p = 0.5, adj = adjlist)




system.time(
  for (i in 1:nSim) {        
   output <-  update_param(output)
   k <- output$K
   res$K[i] <- k
   
   if (length(output$theta) == 0) {
     res$theta[i, ] <-  0
   } else {
   res$theta[i, ] <-   c(output$theta, rep(output$theta[k], N - k))
   }
   
   res$lambda[i, ] <- c(output$lambda, rep(output$lambda[k + 1], N - k))
   res$gamma[i, ] <- output$gamma
   #res$graph[[i]] <- output$graph
   #res$p[i] <- output$p
 
  
  }

  
  
  
)


```






```{r}



burnin = 20000

par(mfrow = c(1,3))
plot(res$gamma[-(1:burnin),1], type = "l")
plot(res$gamma[-(1:burnin),2], type = "l")
plot(res$gamma[-(1:burnin),3], type = "l")
title("Gamma (Endemic) Trace Plots", outer = TRUE)

par(mfrow = c(1,3))
plot(res$theta[,1], type = "l")
plot(res$theta[,2], type = "l")
plot(res$theta[,3], type = "l")
title("Change Point Trace Plots", outer = TRUE)

par(mfrow = c(2,2))
plot(res$lambda[-(1:burnin),1], type = "l")
plot(res$lambda[-(1:burnin),2], type = "l")
plot(res$lambda[-(1:burnin),3], type = "l")
plot(res$lambda[-(1:burnin),4], type = "l")
title("Lambda (epidemic) Trace Plots", outer = TRUE)




par(mfrow = c(2, 3))

plot(colSums(counts), type = "l")
lines(c(177,177), c(0,400), col = "red")
hist(res$K[-(1:burnin)],freq = FALSE, breaks = 5)
plot(density(res$lambda[-(1:burnin), 1], bw=0.01))

plot(density(res$lambda[-(1:burnin), 2], bw=0.01))

plot(density(res$lambda[-(1:burnin), 3], bw=0.01))

plot(density(res$lambda[-(1:burnin), 4][res$K == 4 ], bw=0.01))

title("Actual, #CP and Lambda densities", outer = TRUE)


par(mfrow = c(2, 3))
plot(density(res$theta[-(1:burnin), 1], bw=1))
plot(density(res$theta[-(1:burnin), 2], bw=1))
plot(density(res$theta[-(1:burnin), 3], bw=1))
plot(density(res$theta[-(1:burnin), 4], bw=1))
plot(density(res$theta[-(1:burnin), 5], bw=1))
plot(density(res$theta[-(1:burnin), 6], bw=1))

par(mfrow = c(1, 3))
plot(density(res$gamma[-(1:burnin), 1], bw=0.1))
plot(density(res$gamma[-(1:burnin), 2], bw=0.1))
plot(density(res$gamma[-(1:burnin), 3], bw=0.1))
title("Theta densities", outer = TRUE)


# K <- 4
# 
# theta  <- c(53, 55, 273,280)
# 
# lambda <- c(0.7, 1.5, 0.7, 1.1,0.5)
```


```{r}
colMeans(res$theta[(res$K == 3),1:4])
colMeans(res$theta[(res$K == 2),1:3][-(1:burnin),1:2])

tail(res$theta[(res$K == 4),1:4])
```


