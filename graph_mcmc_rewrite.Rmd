---
title: "Handwritten MCMC 2"
output: html_notebook
---

```{r}
pkgs = c("compiler", "profvis", "igraph","microbenchmark")
inst = lapply(pkgs, library, character.only = TRUE)
```





```{r likelihood}

Rcpp::cppFunction("double mypoisC(NumericVector data, NumericVector lambdas) {
  int n = data.size();
  NumericVector plik(n);
  plik = -lambdas + data*log(lambdas);

  double tlik = 0;

  for(int i = 0; i < n; ++i){
    tlik += plik[i];
  }

  return tlik;
  }")



Rcpp::cppFunction("NumericVector diff_sug(NumericVector x){
   return diff(x);
}")

Rcpp::cppFunction("NumericVector stl_sort(NumericVector x) {
   NumericVector y = clone(x);
   std::sort(y.begin(), y.end());
   return y;
}")

mypoisR <- function(data, lambdas) {
  sum(-lambdas + data*log(lambdas))
}

  compute_like <- function(K, lambda, theta, gamma, INDEP) {
        if (K == 0) {
    vepi_star <- rep(lambda, N)
    
    } else {
      vepi_star <- rep(lambda, diff_sug(c(0, theta, N)))
      
    }
    
    nu <- exp(INDEP %*% gamma)
    vepi <- rep(lambda, diff_sug(c(0, theta, N))) #make into vector
    LL_star <- sum(mypoisC(Z[2:(N + 1)], nu + vepi*Z[1:N])) #likelihood of the new parameters
    
    
    return(LL_star)
  }
  
  
# compute_like <- function(K, lambda, theta, gamma, INDEP) {
#         if (K == 0) {
#     vepi_star <- rep(lambda, N)
#     
#     } else {
#       vepi_star <- rep(lambda, diff(c(0, theta, N)))
#       
#     }
#     
#     nu <- exp(as.matrix(INDEP) %*% gamma)
#     vepi <- rep(lambda, diff(c(0, theta, N))) #make into vector
#     LL_star <- sum(dpois(Z[2:(N + 1)], nu + vepi*Z[1:N], log = TRUE)) #likelihood of the new parameters
#     
#     
#     return(LL_star)
# }


```



```{r graph simulation}
N = 199 #total epochs/time steps
t = 1:N
init = 10   #Z_0 value is the initial number of people infected

el = matrix(
  c(1,2,1,3,1,4,1,5,1,6, 2, 7, 2, 8, 7,8, 6,9, 9, 10),
  byrow = TRUE,
  ncol = 2)

g_city = graph_from_edgelist(el, directed = FALSE)
plot(g_city)



#---simulate endemic component based on paper's values----#
#-----------NOTE: need to divide the rate since each city gets a chance




gamma  <- c(log(10), 0.5, 1.5)
rho <- 2*pi/52 
INDEP <- as.matrix(data.frame(x0 = 1, x1 = sin(rho*t), x2 = cos(rho*t*1.5)))

nu_t <- as.matrix(INDEP) %*% gamma


#need to divide!
ende_lambda = rep(0, N)
ende_lambda = exp(nu_t)




#-----setting epidemic lambda values 

K <- 2
theta  <- c(39, 49)

lambda <- c(0.7, 1.3, 0.7)/4
epi_lambda = rep(lambda, diff(c(0, theta, N)))





#----separate count figures----#
ende_c = matrix(0, nrow = gorder(g_city), ncol = N)
epi_c = matrix(0, nrow = gorder(g_city), ncol = N)



#-----------------counts matrix ------


counts = matrix(0, nrow = gorder(g_city), ncol = N)
counts[1,1] = init

#counts = rep(0, n) #initialize count vector
#counts[1] = init #initial value
 

#get list of all adjacent vertices
adj = adjacent_vertices(g_city, 1:gorder(g_city))



#-----------

for (i in 1:(N - 1)) {
  #all rows/cities get same value
  ende_c[, i] = rpois(1, ende_lambda[i])
  
  for (j in 1:gorder(g_city)) {
    counts_j = sum(counts[adj[[j]], i]) #sum all adjacent counts
    counts_j = counts_j + counts[j, i] #add self count
    epi_c[j, i] = rpois(1, epi_lambda[i] * counts_j) #generate new counts
    counts[j , i + 1] = ende_c[j, i] + epi_c[j, i] #append new counts
  }
  
  
}

plot(colSums(counts), type = 'l')
lines(colSums(ende_c), col = 'blue', type = 'l')
lines(colSums(epi_c), col = 'red', type = 'l')
title(main = "all cities sum")

plot(counts[1, ], type = 'l', col = 'forestgreen')
lines(ende_c[1, ], type = 'l', col = 'blue')
lines(epi_c[1, ], type = 'l', col = 'red')
title(main = 'city 1')

plot(counts[10, ], type = 'l', col = 'forestgreen')
lines(ende_c[10, ], type = 'l', col = 'blue')
lines(epi_c[10, ], type = 'l', col = 'red')
title(main = 'city 10')


```



```{r operators}

change_gamma <- function(input) {


  K = input$K
  theta = input$theta
  lambda = input$lambda
  gamma = input$gamma
  INDEP = input$INDEP
  LL = input$LL
  graph = input$graph
  
  
  gamma_star <- gamma + rnorm(3, 0, 0.01)
  
  input_star = input
  input_star$gamma = gamma_star
  
  LL_star <- compute_like(input_star)
  
  prior_star <-  sum(dgamma(lambda, 1, 1, log = TRUE)) + sum(dunif(theta, 0, N, log = TRUE)) #sum(dgamma(lambda_star, 1, 1, log = TRUE))
  post_star <- LL_star + prior_star #new log posterior
  
  U = runif(1)
  
  if (log(U) < post_star - LL) {
    
    return(list(K = K, theta = theta, lambda = lambda, LL = post_star, gamma = gamma_star, INDEP = INDEP, graph = graph))
    
  } else {
    return(input)
  }
  
  
}



death_theta <- function(input) {
  K = input$K
  theta = input$theta
  lambda = input$lambda
  gamma = input$gamma
  INDEP = input$INDEP
  LL = input$LL
  graph = input$graph


    
    #m <- sample(1:length(theta), 1)
    m <- ceiling(runif(1,0,length(theta)))
    theta_star <- theta[c(-m)]                 # remove

    lambda1 <- lambda[m]     #find adjacent values to change point m
    lambda2 <- lambda[m + 1]
    
    temp_theta = c(0, theta, N)
    j = m + 1
    
    #crate new value
    lambda0 <- lambda1^((temp_theta[j] - temp_theta[j - 1])/(temp_theta[j + 1] - temp_theta[j - 1])) * lambda2^((temp_theta[j + 1] - temp_theta[j])/(temp_theta[j+1] - temp_theta[j-1]))
    
    #new lambda proposal vector
    lambda_star <- lambda
    lambda_star[m] <- lambda0
    lambda_star <- lambda_star[-c(m + 1)]

  
    #edge case handling
    
    input_star <- input
    input_star$lambda <- lambda_star
    input_star$theta <- theta_star

    
    LL_star <- compute_like(input_star)
    
    
    if (K == 1) {
    prior_star <- sum(dgamma(lambda_star, 1, 1, log = TRUE)) 
    } else {
      prior_star <- sum(dgamma(lambda_star, 1, 1, log = TRUE)) + sum(dunif(theta_star, 0, N, log = TRUE))
    }
    
    post_star <- LL_star + prior_star #new log posterior
    
    proposal <- -log(K+1) + log(N-K)
    
    alpha <- post_star - LL - 2*log(lambda1 + lambda2) + log(lambda0) - proposal
    
    if (alpha > log(runif(1))) {
      list(K = K - 1, theta = theta_star, lambda = lambda_star, INDEP = INDEP, gamma = gamma, LL = post_star, graph = graph)
    }  else {
     list(K = K, theta = theta, lambda = lambda,INDEP = INDEP,
                gamma = gamma, LL = LL, graph = graph)
      
    }
    
} 






birth_theta <- function(input) {
  K = input$K
  theta = input$theta
  lambda = input$lambda
  gamma = input$gamma
  INDEP = input$INDEP
  LL = input$LL
  graph = input$graph
  

  
    #theta_m <- sample(setdiff(1:N, theta), 1)  # birth
    theta_m <- ceiling(runif(1, 0, N))
    while (theta_m %in% theta) {
      theta_m <- ceiling(runif(1, 0, N))
    }
    
    theta_star <- stl_sort(c(theta, theta_m))
    
    m <- which(theta_star == theta_m)      
    
    temp_theta_star = c(0, theta_star, N)
    
    u <- runif(1)
    

      j = m+1
      lambda0 <- lambda[m]
      lambda1 <- lambda0*(u/(1 - u))^((temp_theta_star[j] - temp_theta_star[j - 1])/(temp_theta_star[j + 1] - temp_theta_star[j - 1]))
      lambda2 <- lambda0*((1 - u)/u)^((temp_theta_star[j + 1] - temp_theta_star[j])/(temp_theta_star[j + 1] - temp_theta_star[j - 1]))
      
    
    

    
    if (m == 1) {
    
      lambda_star <- c(lambda1, lambda2, lambda[-1])
    }
    else if (m == length(theta_star)) {
      lambda_star <- c(lambda[1:K], lambda1, lambda2)
    }
    else {
      lambda_star <- c(lambda[1:(m - 1)], lambda1, lambda2, lambda[(m + 1):(K + 1)])
    }
      
    input_star <- input
    input_star$lambda <- lambda_star
    input_star$theta <- theta_star

    
    LL_star <- compute_like(input_star)
   
    
    
    if (K == 1) {
    prior_star <- sum(dgamma(lambda_star ,1 , 1, log = TRUE)) 
    } else {
      prior_star <- sum(dgamma(lambda_star ,1 , 1, log = TRUE)) + sum(dunif(theta_star, 0, N, log = TRUE))
    }
    
    post_star <- LL_star + prior_star #new log posterior
    
    proposal <- -log(K+1) + log(N-K)
    

    alpha <- post_star + 2*log(lambda1 + lambda2) - log(lambda0) - LL + proposal
    
    if (alpha > log(runif(1))) list(K = K + 1, theta = theta_star, lambda = lambda_star, INDEP = INDEP, gamma = gamma, LL = post_star, graph = graph)
    else list(K = K, theta = theta, lambda = lambda,INDEP = INDEP,
                gamma = gamma, LL = LL, graph = graph)

  
}
  

change_theta <- function(input) {
  K = input$K
  theta = input$theta
  lambda = input$lambda
  gamma = input$gamma
  INDEP = input$INDEP
  LL = input$LL
  graph = input$graph
  
  

  K <- K
  j <- sample(1:K, size = 1) + 1# select a theta 50, 70
  #j <- ceiling(runif(1,1,K+1))
  
  
  temp_theta <- c(0, theta, N)
  
  s_star <- ceiling(runif(1,temp_theta[j - 1], temp_theta[j + 1] - 1 ))
  #s_star <- temp_theta[j] + sample(c(-1,1),1)
  
  theta_star <- theta
  theta_star[j - 1] <- s_star
  
  input_star <- input
  input_star$theta <- theta_star

   LL_star <- compute_like(input_star) #likelihood of the new parameters
   prior_star <- sum(dgamma(lambda, 1, 1, log = TRUE)) + sum(dunif(theta_star, 0, N, log = TRUE))#0#sum(dgamma(lambda ,2 , 20, log = TRUE))
   post_star <- LL_star + prior_star #new log posterior

  
  #post_star <- compute_post(lambda, theta_star, nu)
  
  
  U <- runif(1)
    
    if (log(U) < post_star - LL) {
    
    return(list(K = K, theta = theta_star, lambda = lambda, INDEP = INDEP, gamma = gamma, LL = post_star, graph = graph))
    
  } else {
    return(list(K = K, theta = theta, lambda = lambda,INDEP = INDEP,
                gamma = gamma, LL = LL, graph = graph))
  }
  
}


change_lambda <- function(input) {
  K = input$K
  theta = input$theta
  lambda = input$lambda
  gamma = input$gamma
  INDEP = input$INDEP
  LL = input$LL
  graph = input$graph
  
  
  K <- K
  j <- sample(1:(K + 1), size = 1)# select a theta 50, 70
  
  lambda_star <- lambda
  lambda_star <- lambda_star + rnorm(K + 1, 0, 0.0025)
  #lambda_star[j] <- lambda_star[j] + rnorm(1,0,0.01)
  
  input_star <- input
  input_star$lambda <- lambda_star
  
  
  LL_star <- compute_like(input_star)
  
  prior_star <-  sum(dgamma(lambda_star, 1, 1, log = TRUE)) + sum(dunif(theta, 0, N, log = TRUE)) #sum(dgamma(lambda_star, 1, 1, log = TRUE))
  post_star <- LL_star + prior_star #new log posterior
  
  
  
  U = runif(1)
  
  if (log(U) < post_star - LL) {
    
    return(list(K = K, theta = theta, lambda = lambda_star, LL = post_star, gamma = gamma, INDEP = INDEP, graph = graph))
    
  } else {
    return(list(K = K, theta = theta, lambda = lambda, LL = LL ,gamma = gamma, INDEP = INDEP, graph = graph))
  }
  
}




## call update_theta then update number of change points K
## and lambda
## then use LL to accept or reject

 

update_param <- function(input) {


  
  
  

  


   cutoff <- 1/5
  
   p = runif(1)
   if (p < cutoff || input$K < 1 ) {
     output <- birth_theta(input)
   } else if (p < 2*cutoff & K > 0) {
     output <- change_theta(input)
   } else if (p < 3*cutoff) {
     output <- change_lambda(input)
   }  else if (p < 4*cutoff) {
     output <- change_gamma(input)
   }
      else if (p >= 4*cutoff & input$K > 0) {
     output <- death_theta(input)
   }


 
  return(output)

}




```


```{r graph likelihood}


compute_like <- function(input) {
    
    K = input$K
    theta = input$theta
    lambda = input$lambda
    gamma = input$gamma
    INth_thetaP = input$INDEP
    LL = input$LL
    graph = input$graph
    
  
    if (K == 0) {
    vepi_star <- rep(lambda, N)
    
    } else {
      vepi_star <- rep(lambda, diff_sug(c(0, theta, N)))
    }

  ord = gorder(graph)
  adj = adjacent_vertices(graph, 1:gorder(graph))
  inf_counts = matrix(0, nrow = gorder(graph), ncol = N)
  
  nu <- exp(INDEP %*% gamma)
  
  for (i in 1:gorder(graph)) {
      inf_counts[i, ] = colSums(counts[adj[[i]], , drop = FALSE]) + counts[i, ]
  }
  
  #creates matrix of repeated rows
  mat_ende_lambda <- matrix(rep(nu, ord), nrow = ord, byrow = TRUE)
  
  #creates matrix of lambdas from estimated lambda row
  mat_lambdas <- matrix(rep(vepi_star, ord), nrow = ord, byrow = TRUE)
  
  #compute the log-likelihood
  log_lik <- sum(dpois(counts[ ,2:N], #data is for 2:N, first column is an initial value
                         inf_counts[ , 1:(N - 1)]*mat_lambdas[, 1:(N - 1)] + mat_ende_lambda[, 1:(N - 1)],
                         log = TRUE))
  log_lik
}

# graph_lik(K, lambda, theta, gamma, INDEP, graph)
# 
# profvis(for (i in 1:1000){graph_lik(K, lambda, theta, gamma, INDEP, graph)})





```








```{r}
#ops = c(death_theta, birth_theta, change_theta, change_lambda, change_gamma)
#lapply(ops, undebug)


# update number of change points theta
# 
# 
# compute_like <- cmpfun(compute_like)
# change_theta <- cmpfun(change_theta)
# birth_theta <- cmpfun(birth_theta)
# death_theta <- cmpfun(death_theta)
# change_gamma <- cmpfun(change_gamma)
# update_param <- cmpfun(update_param)

nSim <- 10000
#pre-allocate
res <- list(K = numeric(nSim),
            theta = matrix(0, nSim, N),
            lambda = matrix(0, nSim, N),
            gamma = matrix(0, nSim, 3),
            graph = vector(mode = "list", N),
            p = numeric(nSim))

 


output <- list(K = 1, theta = c(55), lambda =  c(0.8, 1.5), LL = -Inf,
               gamma = c(1, 1, 1), INDEP = INDEP)


output <- list(K = 1, theta = c(29), lambda = c(0.5,1), LL = -Inf,
               gamma = gamma, INDEP = INDEP, graph = g_city, p = 0.5)






system.time(
  for (i in 1:nSim) {        
   output <-  update_param(output)
   k <- output$K
   res$K[i] <- k
   
   if (length(output$theta) == 0) {
     res$theta[i, ] <-   0
   } else {
   res$theta[i, ] <-   c(output$theta, rep(output$theta[k], N - k))
   }
   
   res$lambda[i, ] <- c(output$lambda, rep(output$lambda[k + 1 ], N - k - 1))
   res$gamma[i, ] <- output$gamma
   #res$graph[[i]] <- output$graph
   #res$p[i] <- output$p

}
)


```






```{r}



burnin = 2

par(mfrow = c(1,3))
plot(res$gamma[-(1:burnin),1], type = "l")
plot(res$gamma[-(1:burnin),2], type = "l")
plot(res$gamma[-(1:burnin),3], type = "l")
title("Gamma (Endemic) Trace Plots", outer = TRUE)

par(mfrow = c(1,3))
plot(res$theta[,1], type = "l")
plot(res$theta[,2], type = "l")
plot(res$theta[,3], type = "l")
title("Change Point Trace Plots", outer = TRUE)

par(mfrow = c(2,2))
plot(res$lambda[-(1:burnin),1], type = "l")
plot(res$lambda[-(1:burnin),2], type = "l")
plot(res$lambda[-(1:burnin),3], type = "l")
plot(res$lambda[-(1:burnin),4], type = "l")
title("Lambda (epidemic) Trace Plots", outer = TRUE)




par(mfrow = c(2, 3))

plot(colSums(counts), type = "l")
plot(density(res$K))
plot(density(res$lambda[-(1:burnin), 1], bw=0.01))
plot(density(res$lambda[-(1:burnin), 2], bw=0.01))
plot(density(res$lambda[-(1:burnin), 3], bw=0.01))
plot(density(res$lambda[-(1:burnin), 4], bw=0.01))
title("Actual, #CP and Lambda densities", outer = TRUE)


par(mfrow = c(1, 3))
plot(density(res$theta[-(1:burnin), 1], bw=1))
plot(density(res$theta[-(1:burnin), 2], bw=1))
plot(density(res$theta[-(1:burnin), 3], bw=1))
title("Theta densities", outer = TRUE)


# K <- 4
# 
# theta  <- c(53, 55, 273,280)
# 
# lambda <- c(0.7, 1.5, 0.7, 1.1,0.5)
```



```{r graph_operators}


change_p <- function(input){
  K = input$K
  theta = input$theta
  lambda = input$lambda
  gamma = input$gamma
  INDEP = input$INDEP
  LL = input$LL
  p <- input$p
  graph <- input$graph
  
  p_star <- p + rnorm(1, 0,0.025)
  if (p_star < 0 || p_star > 1){
    return(list(K = K, theta = theta, lambda = lambda, LL = LL, gamma = gamma, INDEP = INDEP, graph = graph, p = p))
  }
  graph_star = sample_gnp(10, p_star)
  lik <- graph_lik(K, lambda, theta, gamma, INDEP, graph_star)
  
  U = runif(1)
  
  if (log(U) < lik - LL) {
    
    return(list(K = K, theta = theta, lambda = lambda, LL = lik, gamma = gamma, INDEP = INDEP, graph = graph_star, p = p_star))
    
  } else {
    return(list(K = K, theta = theta, lambda = lambda, LL = LL, gamma = gamma, INDEP = INDEP, graph = graph, p = p))
  }
  
  
}


update_param <- function(input){
  change_p(input)
}
```
