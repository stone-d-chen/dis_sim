---
title: "Handwritten MCMC 2"
output: html_notebook
---

```{r simulations}
####
# start to simulate data
####


N <- 299
t <- 1:N
gamma  <- c(log(10), 0.7, 1.5)

K <- 3

theta  <- c(50, 55, 270)

lambda <- c(0.7, 1.5, 0.7, 1)




vlambda <- rep(lambda, diff(c(0, theta, N)))

rho <- 2*pi/52
INDEP <- as.matrix(data.frame(x0=1, x1=sin(rho*t), x2=cos(rho*t)))
nu1 <- exp(as.matrix(INDEP) %*% gamma)

Z <- numeric(N)
Z[1] <- 1


X <- rpois(1:N, nu1)

for (i in 2:(N + 1)) {
  Z[i] <- X[i - 1] + rpois(1, vlambda[i - 1] * Z[i - 1])
}


plot(Z, type = "l")
###
#end of simulation
###
```


```{r likelihood function}
  compute_like <- function(K, lambda, theta, gamma, INDEP) {
        if (K == 0) {
    vepi_star <- rep(lambda, N)
    
    } else {
      vepi_star <- rep(lambda, diff(c(0, theta, N)))
      
    }
    
    nu <- exp(INDEP %*% gamma)
    vepi <- rep(lambda, diff(c(0, theta, N))) #make into vector
    LL_star <- sum(dpois(Z[2:(N + 1)], nu + vepi*Z[1:N], log = T)) #likelihood of the new parameters
    
    return(LL_star)
  }


```





```{r operators}

change_gamma <- function(input) {
  K = input$K
  theta = input$theta
  lambda = input$lambda
  gamma = input$gamma
  INDEP = input$INDEP
  LL = input$LL
  
  
  gamma_star <- gamma + rnorm(3, 0, 0.1)
  
  LL_star <- compute_like(K, lambda, theta, gamma_star, INDEP)
  
  prior_star <-  sum(dgamma(lambda, 1, 1, log = TRUE)) + sum(dunif(theta, 0, N, log = TRUE)) #sum(dgamma(lambda_star, 1, 1, log = TRUE))
  post_star <- LL_star + prior_star #new log posterior
  
  U = runif(1)
  
  if (log(U) < post_star - LL) {
    
    return(list(K = K, theta = theta, lambda = lambda, LL = post_star, gamma = gamma_star, INDEP = INDEP))
    
  } else {
    return(list(K = K, theta = theta, lambda = lambda, LL = LL ,gamma = gamma, INDEP = INDEP))
  }
  
  
}



death_theta <- function(input) {
  K = input$K
  theta = input$theta
  lambda = input$lambda
  gamma = input$gamma
  INDEP = input$INDEP
  LL = input$LL


    
    m <- sample(1:length(theta), 1)                   #sample which to remove
    theta_star <- theta[c(-m)]                 # remove

    lambda1 <- lambda[m]     #find adjacent values to change point m
    lambda2 <- lambda[m + 1]
    
    temp_theta = c(0, theta, N)
    j = m + 1
    
    #crate new value
    lambda0 <- lambda1^((temp_theta[j] - temp_theta[j - 1])/(temp_theta[j + 1] - temp_theta[j - 1])) * lambda2^((temp_theta[j + 1] - temp_theta[j])/(temp_theta[j+1] - temp_theta[j-1]))
    
    #new lambda proposal vector
    lambda_star <- lambda
    lambda_star[m] <- lambda0
    lambda_star <- lambda_star[-c(m + 1)]

  
    #edge case handling

    
    LL_star <- compute_like(K, lambda_star, theta_star, gamma, INDEP)
    
    
    if (K == 1) {
    prior_star <- sum(dgamma(lambda_star, 1, 1, log = TRUE)) 
    } else {
      prior_star <- sum(dgamma(lambda_star, 1, 1, log = TRUE)) + sum(dunif(theta_star, 0, N, log = TRUE))
    }
    
    post_star <- LL_star + prior_star #new log posterior
    
    proposal <- -log(K+1) + log(N-K)
    
    alpha <- post_star - LL - 2*log(lambda1 + lambda2) + log(lambda0) - proposal
    
    if (alpha > log(runif(1))) {
      list(K = K - 1, theta = theta_star, lambda = lambda_star, INDEP = INDEP, gamma = gamma, LL = post_star)
    }  else {
     list(K = K, theta = theta, lambda = lambda,INDEP = INDEP,
                gamma = gamma, LL = LL)
      
    }
    
} 






birth_theta <- function(input) {
  K = input$K
  theta = input$theta
  lambda = input$lambda
  gamma = input$gamma
  INDEP = input$INDEP
  LL = input$LL
  

  
    theta_m <- sample(setdiff(1:N, theta), 1)  # birth
    theta_star <- sort(c(theta, theta_m))
    
    m <- which(theta_star == theta_m)      
    
    temp_theta_star = c(0, theta_star, N)
    
    u <- runif(1)
    

      j = m+1
      lambda0 <- lambda[m]
      lambda1 <- lambda0*(u/(1 - u))^((temp_theta_star[j] - temp_theta_star[j - 1])/(temp_theta_star[j + 1] - temp_theta_star[j - 1]))
      lambda2 <- lambda0*((1 - u)/u)^((temp_theta_star[j + 1] - temp_theta_star[j])/(temp_theta_star[j + 1] - temp_theta_star[j - 1]))
      
    
    

    
    if (m == 1) {
    
      lambda_star <- c(lambda1, lambda2, lambda[-1])
    }
    else if (m == length(theta_star)) {
      lambda_star <- c(lambda[1:K], lambda1, lambda2)
    }
    else {
      lambda_star <- c(lambda[1:(m - 1)], lambda1, lambda2, lambda[(m + 1):(K + 1)])
    }

    LL_star <- compute_like(K, lambda_star, theta_star, gamma, INDEP)
   
    
    
    if (K == 1) {
    prior_star <- sum(dgamma(lambda_star ,1 , 1, log = TRUE)) 
    } else {
      prior_star <- sum(dgamma(lambda_star ,1 , 1, log = TRUE)) + sum(dunif(theta_star, 0, N, log = TRUE))
    }
    
    post_star <- LL_star + prior_star #new log posterior
    
    proposal <- -log(K+1) + log(N-K)
    

    alpha <- post_star + 2*log(lambda1 + lambda2) - log(lambda0) - LL + proposal
    
    if (alpha > log(runif(1))) list(K = K + 1, theta = theta_star, lambda = lambda_star, INDEP = INDEP, gamma = gamma, LL = post_star)
    else list(K = K, theta = theta, lambda = lambda,INDEP = INDEP,
                gamma = gamma, LL = LL)

  
}
  

change_theta <- function(input) {
  K = input$K
  theta = input$theta
  lambda = input$lambda
  gamma = input$gamma
  INDEP = input$INDEP
  LL = input$LL
  
  

  K <- K
  j <- sample(1:K, size = 1) + 1# select a theta 50, 70
  
  
  temp_theta <- c(0, theta, N)
  
  s_star <- ceiling(runif(1,temp_theta[j - 1], temp_theta[j + 1] - 1 ))
  #s_star <- temp_theta[j] + sample(c(-1,1),1)
  
  theta_star <- theta
  theta_star[j - 1] <- s_star



   LL_star <- compute_like(K, lambda, theta_star, gamma, INDEP) #likelihood of the new parameters
   prior_star <- sum(dgamma(lambda, 1, 1, log = TRUE)) + sum(dunif(theta_star, 0, N, log = TRUE))#0#sum(dgamma(lambda ,2 , 20, log = TRUE))
   post_star <- LL_star + prior_star #new log posterior

  
  #post_star <- compute_post(lambda, theta_star, nu)
  
  
  U <- runif(1)
    
    if (log(U) < post_star - LL) {
    
    return(list(K = K, theta = theta_star, lambda = lambda, INDEP = INDEP, gamma = gamma, LL = post_star))
    
  } else {
    return(list(K = K, theta = theta, lambda = lambda,INDEP = INDEP,
                gamma = gamma, LL = LL))
  }
  
}


change_lambda <- function(input) {
  K = input$K
  theta = input$theta
  lambda = input$lambda
  gamma = input$gamma
  INDEP = input$INDEP
  LL = input$LL
  
  
  K <- K
  j <- sample(1:(K + 1), size = 1)# select a theta 50, 70
  
  lambda_star <- lambda
  lambda_star <- lambda_star + rnorm(K + 1, 0, 0.02)
  #lambda_star[j] <- lambda_star[j] + rnorm(1,0,0.01)
  
  LL_star <- compute_like(K, lambda_star, theta, gamma, INDEP)
  
  prior_star <-  sum(dgamma(lambda_star, 1, 1, log = TRUE)) + sum(dunif(theta, 0, N, log = TRUE)) #sum(dgamma(lambda_star, 1, 1, log = TRUE))
  post_star <- LL_star + prior_star #new log posterior
  
  
  
  U = runif(1)
  
  if (log(U) < post_star - LL) {
    
    return(list(K = K, theta = theta, lambda = lambda_star, LL = post_star, gamma = gamma, INDEP = INDEP))
    
  } else {
    return(list(K = K, theta = theta, lambda = lambda, LL = LL ,gamma = gamma, INDEP = INDEP))
  }
  
}




## call update_theta then update number of change points K
## and lambda
## then use LL to accept or reject

 

update_param <- function(input) {
  
  
  
  cutoff <- 1/5
  
  p = runif(1)
  if (p < cutoff) {
    output <- birth_theta(input)
  } else if (p < 2*cutoff & K > 0) {
    output <- change_theta(input)
  } else if (p < 3*cutoff) {
    output <- change_lambda(input)
  }  else if (p < 4*cutoff) {
    output <- change_gamma(input)
  }
     else if (p >= 4*cutoff & K > 0) {
    output <- death_theta(input)
  }
  

 
  return(output)

}

```


```{r}

# update number of change points theta
# library(compiler)
# ops = c(compute_like, change_theta, birth_theta, death_theta, change_gamma, change_lambda)
# 
# compute_like <- cmpfun(compute_like)
# change_theta <- cmpfun(change_theta)
# birth_theta <- cmpfun(birth_theta)
# death_theta <- cmpfun(death_theta)
# change_gamma <- cmpfun(change_gamma)
# update_param <- cmpfun(update_param)

nSim <- 100000
#pre-allocate
res <- list(K = numeric(nSim),
            theta = matrix(0, nSim, N),
            lambda = matrix(0, nSim, N),
            gamma = matrix(0, nSim, 3))

 


output <- list(K = 4, theta = c(55, 60, 250,278), lambda =  c(0.8, 1.5, 0.7, 1.1, 1.1), LL = -Inf,
               gamma = c(1, 1, 1), INDEP = INDEP)

library(profvis)

system.time(
  for (i in 1:nSim) {        
   output <-  update_param(output)
   k <- output$K
   res$K[i] <- k
   
   if (length(output$theta) == 0) {
     res$theta[i, ] <-   0
   } else {
   res$theta[i, ] <-   c(output$theta, rep(output$theta[k], N - k))
   }
   
   res$lambda[i, ] <- c(output$lambda, rep(output$lambda[k + 1 ], N - k - 1))
   res$gamma[i, ] <- output$gamma

}
)




```






```{r}



burnin = 20000

par(mfrow = c(1,3))
plot(res$gamma[,1], type = "l")
plot(res$gamma[,2], type = "l")
plot(res$gamma[,3], type = "l")
title("Gamma (Endemic) Trace Plots", outer = TRUE)

par(mfrow = c(1,3))
plot(res$theta[,1], type = "l")
plot(res$theta[,2], type = "l")
plot(res$theta[,3], type = "l")
title("Change Point Trace Plots", outer = TRUE)

par(mfrow = c(2,2))
plot(res$lambda[-(1:burnin),1], type = "l")
plot(res$lambda[-(1:burnin),2], type = "l")
plot(res$lambda[-(1:burnin),3], type = "l")
plot(res$lambda[-(1:burnin),4], type = "l")
title("Lambda (epidemic) Trace Plots", outer = TRUE)




par(mfrow = c(2, 3))

plot(Z, type = "l")
plot(density(res$K))
plot(density(res$lambda[-(1:burnin), 1], bw=0.01))
plot(density(res$lambda[-(1:burnin), 2], bw=0.01))
plot(density(res$lambda[-(1:burnin), 3], bw=0.01))
plot(density(res$lambda[-(1:burnin), 4], bw=0.01))
title("Actual, #CP and Lambda densities", outer = TRUE)


par(mfrow = c(1, 3))
plot(density(res$theta[-(1:burnin), 1], bw=1))
plot(density(res$theta[-(1:burnin), 2], bw=1))
plot(density(res$theta[-(1:burnin), 3], bw=1))
title("Theta densities", outer = TRUE)


# K <- 4
# 
# theta  <- c(53, 55, 273,280)
# 
# lambda <- c(0.7, 1.5, 0.7, 1.1,0.5)
```

